<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>staticlib_concurrent: staticlib::concurrent::spsc_waiting_queue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">staticlib_concurrent
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestaticlib.html">staticlib</a></li><li class="navelem"><a class="el" href="namespacestaticlib_1_1concurrent.html">concurrent</a></li><li class="navelem"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">staticlib::concurrent::spsc_waiting_queue&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Queue with the same logic as <code><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__concurrent__queue.html" title="Wait-free queue with fixed-size heap storage.">spsc_concurrent_queue</a></code> with additional optional blocking <code>take</code> operation.  
 <a href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spsc__waiting__queue_8hpp_source.html">staticlib/concurrent/spsc_waiting_queue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8674f7fbb5772d5c0f241445361e567f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a8674f7fbb5772d5c0f241445361e567f">spsc_waiting_queue</a> (size_t <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a4f5ef8d071704391868015ecbbdf40ee">size</a>)</td></tr>
<tr class="memitem:a577fe517bfa15b3dd714332ff07edfb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a577fe517bfa15b3dd714332ff07edfb1">spsc_waiting_queue</a> (const <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> &amp;)</td></tr>
<tr class="memdesc:a577fe517bfa15b3dd714332ff07edfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#a577fe517bfa15b3dd714332ff07edfb1"></a><br/></td></tr>
<tr class="memitem:ab617b626e689061e2a146a6abc9ebf85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#ab617b626e689061e2a146a6abc9ebf85">operator=</a> (const <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> &amp;)</td></tr>
<tr class="memdesc:ab617b626e689061e2a146a6abc9ebf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <a href="#ab617b626e689061e2a146a6abc9ebf85"></a><br/></td></tr>
<tr class="memitem:a020894ab750a5a4f2846201221cce28d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a020894ab750a5a4f2846201221cce28d">spsc_waiting_queue</a> (<a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a020894ab750a5a4f2846201221cce28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor.  <a href="#a020894ab750a5a4f2846201221cce28d"></a><br/></td></tr>
<tr class="memitem:a1ee6c13f1125a22e84832e8ebf0b59d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a1ee6c13f1125a22e84832e8ebf0b59d3">operator=</a> (<a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a1ee6c13f1125a22e84832e8ebf0b59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment operator.  <a href="#a1ee6c13f1125a22e84832e8ebf0b59d3"></a><br/></td></tr>
<tr class="memitem:a0153a5cc5114e1d0d5b5dcffd6d7bf42"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a0153a5cc5114e1d0d5b5dcffd6d7bf42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a0153a5cc5114e1d0d5b5dcffd6d7bf42">emplace</a> (Args &amp;&amp;...record_args)</td></tr>
<tr class="memdesc:a0153a5cc5114e1d0d5b5dcffd6d7bf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a value at the end of the queue.  <a href="#a0153a5cc5114e1d0d5b5dcffd6d7bf42"></a><br/></td></tr>
<tr class="memitem:a0e846219b84d52cdcdfb93cf3224b933"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a0e846219b84d52cdcdfb93cf3224b933">poll</a> (T &amp;record)</td></tr>
<tr class="memdesc:a0e846219b84d52cdcdfb93cf3224b933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read the value at the front to the queue into a variable.  <a href="#a0e846219b84d52cdcdfb93cf3224b933"></a><br/></td></tr>
<tr class="memitem:a11e98b9ce4cde79beb34342aab03de1d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a11e98b9ce4cde79beb34342aab03de1d">front_ptr</a> ()</td></tr>
<tr class="memdesc:a11e98b9ce4cde79beb34342aab03de1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the item at the front of the queue.  <a href="#a11e98b9ce4cde79beb34342aab03de1d"></a><br/></td></tr>
<tr class="memitem:aac9d62e193eae21e4c1d2b79043dd552"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#aac9d62e193eae21e4c1d2b79043dd552">take</a> (T &amp;record, std::chrono::milliseconds timeout=std::chrono::milliseconds(0))</td></tr>
<tr class="memdesc:aac9d62e193eae21e4c1d2b79043dd552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read the value at the front of the queue into a variable.  <a href="#aac9d62e193eae21e4c1d2b79043dd552"></a><br/></td></tr>
<tr class="memitem:a2bd4f70297c54f1882499fa215b4a6e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a2bd4f70297c54f1882499fa215b4a6e9">unblock</a> ()</td></tr>
<tr class="memdesc:a2bd4f70297c54f1882499fa215b4a6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblocks the queue allowing consumers to exit 'take' calls.  <a href="#a2bd4f70297c54f1882499fa215b4a6e9"></a><br/></td></tr>
<tr class="memitem:ac75e452e949b9a09f36bb7a9ceee35b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#ac75e452e949b9a09f36bb7a9ceee35b9">is_unblocked</a> () const </td></tr>
<tr class="memdesc:ac75e452e949b9a09f36bb7a9ceee35b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this queue was unblocked.  <a href="#ac75e452e949b9a09f36bb7a9ceee35b9"></a><br/></td></tr>
<tr class="memitem:a1619194973ee1e8d182b016b34211577"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a1619194973ee1e8d182b016b34211577">empty</a> () const </td></tr>
<tr class="memdesc:a1619194973ee1e8d182b016b34211577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the queue is empty.  <a href="#a1619194973ee1e8d182b016b34211577"></a><br/></td></tr>
<tr class="memitem:ae2381fd77603de7efbde768119200960"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#ae2381fd77603de7efbde768119200960">full</a> () const </td></tr>
<tr class="memdesc:ae2381fd77603de7efbde768119200960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the queue is full.  <a href="#ae2381fd77603de7efbde768119200960"></a><br/></td></tr>
<tr class="memitem:a4f5ef8d071704391868015ecbbdf40ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#a4f5ef8d071704391868015ecbbdf40ee">size</a> () const </td></tr>
<tr class="memdesc:a4f5ef8d071704391868015ecbbdf40ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the queue.  <a href="#a4f5ef8d071704391868015ecbbdf40ee"></a><br/></td></tr>
<tr class="memitem:ab79ce141ab069f3538b953d5db827d07"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html#ab79ce141ab069f3538b953d5db827d07">max_size</a> () const </td></tr>
<tr class="memdesc:ab79ce141ab069f3538b953d5db827d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for max queue size specified at creation.  <a href="#ab79ce141ab069f3538b953d5db827d07"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class staticlib::concurrent::spsc_waiting_queue&lt; T &gt;</h3>

<p>Queue with the same logic as <code><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__concurrent__queue.html" title="Wait-free queue with fixed-size heap storage.">spsc_concurrent_queue</a></code> with additional optional blocking <code>take</code> operation. </p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8674f7fbb5772d5c0f241445361e567f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::<a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a577fe517bfa15b3dd714332ff07edfb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::<a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a class="anchor" id="a020894ab750a5a4f2846201221cce28d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::<a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deleted move constructor. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a0153a5cc5114e1d0d5b5dcffd6d7bf42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>record_args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace a value at the end of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recordArgs</td><td>constructor arguments for queue element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the queue was full, true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1619194973ee1e8d182b016b34211577"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the queue is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>whether queue is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a11e98b9ce4cde79beb34342aab03de1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::front_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a pointer to the item at the front of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the item, nullptr if it is empty </dd></dl>

</div>
</div>
<a class="anchor" id="ae2381fd77603de7efbde768119200960"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the queue is full. </p>
<dl class="section return"><dt>Returns</dt><dd>whether queue is full </dd></dl>

</div>
</div>
<a class="anchor" id="ac75e452e949b9a09f36bb7a9ceee35b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::is_unblocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this queue was unblocked. </p>
<dl class="section return"><dt>Returns</dt><dd>whether this queue was unblocked </dd></dl>

</div>
</div>
<a class="anchor" id="ab79ce141ab069f3538b953d5db827d07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for max queue size specified at creation. </p>
<dl class="section return"><dt>Returns</dt><dd>max queue size </dd></dl>

</div>
</div>
<a class="anchor" id="ab617b626e689061e2a146a6abc9ebf85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a>&amp; <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>

</div>
</div>
<a class="anchor" id="a1ee6c13f1125a22e84832e8ebf0b59d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a>&amp; <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">spsc_waiting_queue</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deleted move assignment operator. </p>

</div>
</div>
<a class="anchor" id="a0e846219b84d52cdcdfb93cf3224b933"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::poll </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read the value at the front to the queue into a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>move (or copy) the value at the front of the queue to given variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns false if queue was empty, true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a4f5ef8d071704391868015ecbbdf40ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of entries in the queue. </p>
<p>If called by consumer, then true size may be more (because producer may be adding items concurrently). If called by producer, then true size may be less (because consumer may be removing items concurrently). It is undefined to call this from any other thread.</p>
<dl class="section return"><dt>Returns</dt><dd>number of entries in the queue </dd></dl>

</div>
</div>
<a class="anchor" id="aac9d62e193eae21e4c1d2b79043dd552"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::take </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read the value at the front of the queue into a variable. </p>
<p>This method will wait on empty queue infinitely (by default), or up to specified amount of milliseconds</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>move (or copy) the value at the front of the queue to given variable </td></tr>
    <tr><td class="paramname">timeout</td><td>max amount of milliseconds to wait on empty queue, zero value (supplied by default) will cause infinite wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns false if queue was empty after timeout, true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2bd4f70297c54f1882499fa215b4a6e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstaticlib_1_1concurrent_1_1spsc__waiting__queue.html">staticlib::concurrent::spsc_waiting_queue</a>&lt; T &gt;::unblock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unblocks the queue allowing consumers to exit 'take' calls. </p>
<p>Queue cannot be used for waiting on it after this call. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>staticlib/concurrent/<a class="el" href="spsc__waiting__queue_8hpp_source.html">spsc_waiting_queue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 10 2017 11:07:34 for staticlib_concurrent by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
